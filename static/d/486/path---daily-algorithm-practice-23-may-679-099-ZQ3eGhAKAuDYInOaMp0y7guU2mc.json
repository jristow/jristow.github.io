{"data":{"site":{"siteMetadata":{"title":"Jordan Ristow","author":"Jordan Ristow"}},"markdownRemark":{"id":"7e56d096-b55d-5f44-b9f9-83fd68bfaaa0","excerpt":"Problem Statement:Consider all the leaves of a binary tree. From left to right order, the values of those leaves form a leaf value sequence.\nFor example, in the…","html":"<h2>Problem Statement:</h2>\n<p>Consider all the leaves of a binary tree. From left to right order, the values of those leaves form a leaf value sequence.</p>\n<p>\n  <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/6b2d738f6141e4f1051eb145220cf9c9/74efd/binaryTree.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n  \n  <span\n    class=\"gatsby-resp-image-wrapper\"\n    style=\"position: relative; display: block;  max-width: 590px; margin-left: auto; margin-right: auto;\"\n  >\n    <span\n      class=\"gatsby-resp-image-background-image\"\n      style=\"padding-bottom: 83.94557823129252%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAARCAIAAABSJhvpAAAACXBIWXMAAAsSAAALEgHS3X78AAABoklEQVQ4y5VTTVPbMBDl//+Ucuyl5ZQZmMmFACEwcVLbcVzbEEeKZH1Ysj4cZASe4MbMVCftat++3X2ri+P4EUJQStu2HQu4GHuw1hZFHoYRIcyZZ1OMgo2xySZ5mD+97sB/gwmhB1RVhJUlOI5UPgR7BtctgAfvYYwjhNvW/ks+BCulsiyL40RK1efa7/d5UeCKjIJ9HGNsvVotgzWhvPdjjP9m2Z8wcVM8A/YFtdZCCB1tmhanRQohwyiJ4rRpVB88ZAYASNkQSpXSg4pcUq01hAeX6AuzVPb10OxK6ObkzDwv4Oe0/Gm0jTIkGvOeBb1Ajpn+AIc5/fFrFqTY0fC63m438SZhrO5po4JeXt0FadUFqOPPydNktuVCd+A9ltf3aZIjL28QrB8Xy1MwwPLmIY2zrhxtj/er3e1zIRv90bOxnYy+ba0N58Jp+3Xh2n7ULqHbv6HOmNYVof6OMKnfpT6Z3LkN896qtpPZxvXvH+YhmC4y0bSn2oyCATXX85fb5c6YbqrTRf57GgJUj/2Koc4lEq5Yb3JpS8itsd98+Dc0kdxNTPMHUwAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n    >\n      <img\n        class=\"gatsby-resp-image-image\"\n        style=\"width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px white;\"\n        alt=\"binaryTree\"\n        title=\"\"\n        src=\"/static/6b2d738f6141e4f1051eb145220cf9c9/b9e4f/binaryTree.png\"\n        srcset=\"/static/6b2d738f6141e4f1051eb145220cf9c9/cf440/binaryTree.png 148w,\n/static/6b2d738f6141e4f1051eb145220cf9c9/d2d38/binaryTree.png 295w,\n/static/6b2d738f6141e4f1051eb145220cf9c9/b9e4f/binaryTree.png 590w,\n/static/6b2d738f6141e4f1051eb145220cf9c9/74efd/binaryTree.png 735w\"\n        sizes=\"(max-width: 590px) 100vw, 590px\"\n      />\n    </span>\n  </span>\n  \n  </a>\n    \nFor example, in the given tree above, the leaf value sequence is (6, 7, 4, 9, 8).</p>\n<p>Two binary trees are considered leaf-similar if their leaf value sequence is the same.</p>\n<p>Return true if and only if the two given trees with head nodes root1 and root2 are leaf-similar.</p>\n<h2>Solution Description:</h2>\n<p>This problem is a variation of a depth first search problem. In this implementation of DFS, we need to build out our list of leaf nodes for each root node and then compare these lists to see if they are equivalent. The code implementation of this is below (language used is Python).</p>\n<div class=\"gatsby-highlight\" data-language=\"python\"><pre class=\"language-python\"><code class=\"language-python\"><span class=\"token keyword\">def</span> <span class=\"token function\">leafSimilar</span><span class=\"token punctuation\">(</span>root1<span class=\"token punctuation\">,</span> root2<span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n        <span class=\"token keyword\">def</span> <span class=\"token function\">dfs</span><span class=\"token punctuation\">(</span>node<span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n            <span class=\"token keyword\">if</span> node<span class=\"token punctuation\">:</span>\n                <span class=\"token keyword\">if</span> <span class=\"token keyword\">not</span> node<span class=\"token punctuation\">.</span>left <span class=\"token keyword\">and</span> <span class=\"token keyword\">not</span> node<span class=\"token punctuation\">.</span>right<span class=\"token punctuation\">:</span>\n                    <span class=\"token keyword\">yield</span> node<span class=\"token punctuation\">.</span>val\n                <span class=\"token keyword\">yield</span> <span class=\"token keyword\">from</span> dfs<span class=\"token punctuation\">(</span>node<span class=\"token punctuation\">.</span>left<span class=\"token punctuation\">)</span>\n                <span class=\"token keyword\">yield</span> <span class=\"token keyword\">from</span> dfs<span class=\"token punctuation\">(</span>node<span class=\"token punctuation\">.</span>right<span class=\"token punctuation\">)</span>\n\n        <span class=\"token keyword\">return</span> <span class=\"token builtin\">list</span><span class=\"token punctuation\">(</span>dfs<span class=\"token punctuation\">(</span>root1<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">==</span> <span class=\"token builtin\">list</span><span class=\"token punctuation\">(</span>dfs<span class=\"token punctuation\">(</span>root2<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span></code></pre></div>\n<p>Above we have the implementation, now let’s walk through it to look under the hood a little. We will skip over the def lines and jump straight into the good parts.</p>\n<div class=\"gatsby-highlight\" data-language=\"python\"><pre class=\"language-python\"><code class=\"language-python\"> <span class=\"token keyword\">if</span> <span class=\"token keyword\">not</span> node<span class=\"token punctuation\">.</span>left <span class=\"token keyword\">and</span> <span class=\"token keyword\">not</span> node<span class=\"token punctuation\">.</span>right<span class=\"token punctuation\">:</span>\n     <span class=\"token keyword\">yield</span> node<span class=\"token punctuation\">.</span>val</code></pre></div>\n<p>This chunk is our base case test: if there is a value in either node.left or node.right, this node is not a leaf. If there are no values in either node.left or node.right, we yield the value of the node. Note the use of yield here instead of return, this allows us to pass a value while still maintaining state.</p>\n<div class=\"gatsby-highlight\" data-language=\"python\"><pre class=\"language-python\"><code class=\"language-python\"><span class=\"token keyword\">yield</span> <span class=\"token keyword\">from</span> dfs<span class=\"token punctuation\">(</span>node<span class=\"token punctuation\">.</span>left<span class=\"token punctuation\">)</span>\n<span class=\"token keyword\">yield</span> <span class=\"token keyword\">from</span> dfs<span class=\"token punctuation\">(</span>node<span class=\"token punctuation\">.</span>right<span class=\"token punctuation\">)</span></code></pre></div>\n<p>This chunk is the heart of our recursive call. The first line passes the left child of the node into our depth first search function while the second line passes the right child. </p>\n<div class=\"gatsby-highlight\" data-language=\"python\"><pre class=\"language-python\"><code class=\"language-python\">  <span class=\"token keyword\">return</span> <span class=\"token builtin\">list</span><span class=\"token punctuation\">(</span>dfs<span class=\"token punctuation\">(</span>root1<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">==</span> <span class=\"token builtin\">list</span><span class=\"token punctuation\">(</span>dfs<span class=\"token punctuation\">(</span>root2<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span></code></pre></div>\n<p>This is the final line, where we call our dfs function with our two root values. Wrapping the dfs function in the list method allows us to build out a list of all the leaf nodes that are yielded from our function (the main reason we used yield instead of return in our function). Once both lists have been built, we check if they are equivalent, finally returning True or False based on that check.</p>","frontmatter":{"title":"Daily Algorithm Work May 23, 2019","date":"May 23, 2019","description":"Daily practice on algorithms"}}},"pageContext":{"isCreatedByStatefulCreatePages":false,"slug":"/daily-algorithm-practice-23-may/","previous":{"fields":{"slug":"/missing-places/"},"frontmatter":{"title":"Missing Places"}},"next":{"fields":{"slug":"/react-conversion-part-one/"},"frontmatter":{"title":"Building a React Based Portfolio Index Site"}}}}