{"data":{"site":{"siteMetadata":{"title":"Jordan Ristow","author":"Jordan Ristow"}},"markdownRemark":{"id":"97267b48-40c3-5e20-9fb5-7482b9b79725","excerpt":"Problem StatementGiven a string containing just the characters ’(’, ’)’, ’{’,’}’, ’’, ’’, determine if the input string is valid. An input string is valid if…","html":"<h2>Problem Statement</h2>\n<p>Given a string containing just the characters ’(’, ’)’, ’{’,’}’, ’[’, ’]’, determine if the input string is valid. An input string is valid if:</p>\n<ul>\n<li>Open brackets must be closed by the same type of bracket.</li>\n<li>Open brackets must be closed in the correct order.\nNote that an empty string is also considered valid.</li>\n</ul>\n<h2>Description of Algorithm</h2>\n<p>For this implementation, we will be sacrificing some memory space to speed up our algorithm. The basic logic of the algorithm is:</p>\n<ul>\n<li>\n<p>For each character in the string</p>\n<ul>\n<li>\n<p>We check if it is in a dictionary of closing parentheses.</p>\n<ul>\n<li>If so, we then remove the top item from a stack if present, or use a  placeholder value</li>\n<li>\n<p>We then check if the pair value of the current character in our dictionary is the same as what we removed from the stack.</p>\n<ul>\n<li>If it is not, we return False because there is one closing parenthesis that does not have a matching opening one.</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>If the item is not a closing parenthesis, we then push it to our stack</li>\n</ul>\n</li>\n<li>After reviewing each item in the string, we return whether the stack is empty, which will tell us whether there were any spare opening parenthesis.</li>\n</ul>\n<h2>Algorithm in Code</h2>\n<div class=\"gatsby-highlight\" data-language=\"python\"><pre class=\"language-python\"><code class=\"language-python\"><span class=\"token keyword\">def</span> <span class=\"token function\">isValid</span><span class=\"token punctuation\">(</span>s<span class=\"token punctuation\">:</span> string<span class=\"token punctuation\">)</span> <span class=\"token operator\">-</span><span class=\"token operator\">></span> <span class=\"token builtin\">bool</span><span class=\"token punctuation\">:</span>\n    stack <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span>\n    mapping <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span><span class=\"token string\">\")\"</span><span class=\"token punctuation\">:</span> <span class=\"token string\">\"(\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"}\"</span><span class=\"token punctuation\">:</span> <span class=\"token string\">\"{\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"]\"</span><span class=\"token punctuation\">:</span> <span class=\"token string\">\"[\"</span> <span class=\"token punctuation\">}</span>\n\n    <span class=\"token keyword\">for</span> char <span class=\"token keyword\">in</span> s<span class=\"token punctuation\">:</span>\n        <span class=\"token keyword\">if</span> char <span class=\"token keyword\">in</span> mapping<span class=\"token punctuation\">:</span>\n            top_element <span class=\"token operator\">=</span> stack<span class=\"token punctuation\">.</span>pop<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">if</span> stack <span class=\"token keyword\">else</span> <span class=\"token string\">'#'</span>\n            <span class=\"token keyword\">if</span> mapping<span class=\"token punctuation\">[</span>char<span class=\"token punctuation\">]</span> <span class=\"token operator\">!=</span> top_element<span class=\"token punctuation\">:</span>\n                <span class=\"token keyword\">return</span> <span class=\"token boolean\">False</span>\n        <span class=\"token keyword\">else</span><span class=\"token punctuation\">:</span>\n            stack<span class=\"token punctuation\">.</span>append<span class=\"token punctuation\">(</span>char<span class=\"token punctuation\">)</span>\n\n    <span class=\"token keyword\">return</span> <span class=\"token keyword\">not</span> stack</code></pre></div>\n<h2>Walkthrough of Algorithm</h2>\n<p>Starting at the top of our code, we have:</p>\n<div class=\"gatsby-highlight\" data-language=\"python\"><pre class=\"language-python\"><code class=\"language-python\">stack <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span>\nmapping <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span><span class=\"token string\">\")\"</span><span class=\"token punctuation\">:</span><span class=\"token string\">\"(\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"}\"</span><span class=\"token punctuation\">:</span> <span class=\"token string\">\"{\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"]\"</span><span class=\"token punctuation\">:</span><span class=\"token string\">\"[\"</span><span class=\"token punctuation\">}</span></code></pre></div>\n<p>This section just creates our extra data structures we will use to store our opening parentheses as we progress through and the dictionary mapping our closing parentheses to the correct opening one.</p>\n<div class=\"gatsby-highlight\" data-language=\"pythong\"><pre class=\"language-pythong\"><code class=\"language-pythong\">for char in s:</code></pre></div>\n<p>This sets up our iteration through the string.</p>\n<div class=\"gatsby-highlight\" data-language=\"python\"><pre class=\"language-python\"><code class=\"language-python\"><span class=\"token keyword\">if</span> char <span class=\"token keyword\">in</span> mapping<span class=\"token punctuation\">:</span>\n    top_element <span class=\"token operator\">=</span> stack<span class=\"token punctuation\">.</span>pop<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">if</span> stack <span class=\"token keyword\">else</span> <span class=\"token string\">'#'</span>\n    <span class=\"token keyword\">if</span> mapping<span class=\"token punctuation\">[</span>char<span class=\"token punctuation\">]</span> <span class=\"token operator\">!=</span> top_element<span class=\"token punctuation\">:</span>\n        <span class=\"token keyword\">return</span> <span class=\"token boolean\">False</span></code></pre></div>\n<p>This code chunk is the logic that looks up each char to see if it is a key in our dictionary of closing parentheses. If it is, we remove the top element of our stack, if there is any, or create a placeholder value if the stack is empty. If this top_element is not the same as the value corresponding to the char key in our dictionary, we know there is one closing parenthesis that does not have a matching opening parenthesis. So we return False.</p>\n<div class=\"gatsby-highlight\" data-language=\"python\"><pre class=\"language-python\"><code class=\"language-python\"><span class=\"token keyword\">else</span><span class=\"token punctuation\">:</span>\n    stack<span class=\"token punctuation\">.</span>append<span class=\"token punctuation\">(</span>char<span class=\"token punctuation\">)</span></code></pre></div>\n<p>Here, we know that the char is an opening parenthesis so we add it to our stack.</p>\n<div class=\"gatsby-highlight\" data-language=\"python\"><pre class=\"language-python\"><code class=\"language-python\"><span class=\"token keyword\">return</span> <span class=\"token keyword\">not</span> stack</code></pre></div>\n<p>This line can be tricky, the logic for it is below:</p>\n<ul>\n<li>\n<p>First check if there is anything left on the stack.</p>\n<ul>\n<li>If there is, we get a True value</li>\n<li>If there is not, we get a False value</li>\n</ul>\n</li>\n<li>We then take that True or False value and negate it with the not keyword.</li>\n<li>\n<p>Finally we return that negation.\nThis process works because, if there is anything on the stack we know that there was at least one opening parenthesis that did not have a corresponding closing parenthesis. This means our string was not valid, so returning not True gives us the correct evaluation.</p>\n<h2>Conclusion</h2>\n<p>This algorithm is efficient in time, as we only need to make one pass through the entire string to determine if it is valid. We also will require, at worst, n space if we push all elements onto our stack. In this case, the trade off in space for less time complexity is a benefit.</p>\n</li>\n</ul>","frontmatter":{"title":"Daily Algorithm Practice - Valid Parentheses","date":"May 31, 2019","description":"Todays algorithm practice problem looks at using a stack to check whether a passed in string contains a closing parenthesis for each opening parenthesis."}}},"pageContext":{"isCreatedByStatefulCreatePages":false,"slug":"/daily-algorithm-31-may/","previous":{"fields":{"slug":"/daily-algorithm-30-may/"},"frontmatter":{"title":"Daily Algorithm Practice - Remove Elements From a Linked List"}},"next":null}}